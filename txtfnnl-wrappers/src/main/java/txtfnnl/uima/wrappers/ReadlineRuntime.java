package txtfnnl.uima.wrappers;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

import org.apache.uima.util.Level;
import org.apache.uima.util.Logger;

/**
 * Implement a process wrapper that takes a line-based input and output
 * stream with a UIMA {@link org.apache.uima.util.Logger} that prints the
 * error stream. The output stream should parsed/converted to a generic type,
 * which needs to be implemented by any children, including the number of
 * output lines to read.
 *
 * @author Florian Leitner
 */
public abstract class ReadlineRuntime<T> {

	/** The forked process. */
	final Process proc;

	/** The stream to send data to the forked process. */
	final BufferedWriter in;

	/** The stream to fetch data from the forked process. */
	final BufferedReader out;

	/** The error stream generated by the forked process. */
	final ReadlineLogger logger;

	/**
	 * Fork out a new {@link Runtime} process.
	 * 
	 * @param args for the Runtime process
	 * @param envp environment parameters (as <i>name=value</i> strings) for
	 *        the Runtime process
	 * @param dir to run the process in
	 * @param encoding for the readline interface
	 * @param logger to handle the error stream
	 * @throws IOException on failure
	 */
	public ReadlineRuntime(String[] args, String[] envp, File dir,
	                       String encoding, Logger logger) throws IOException {
		if (args == null || args.length == 0)
			throw new RuntimeException(
			    "trying to start a runtime without arguments");

		logger.log(Level.FINE,
		    "starting a {{1}} encoded runtime process for ''{0}''",
		    new Object[] { args[0], encoding });
		proc = Runtime.getRuntime().exec(args, envp, dir);
		out = new BufferedReader(new InputStreamReader(proc.getInputStream(),
		    encoding));
		in = new BufferedWriter(new OutputStreamWriter(proc.getOutputStream(),
		    encoding));
		this.logger = new ReadlineLogger(proc.getErrorStream(), logger);
		this.logger.start();
	}

	/**
	 * Fork out a new {@link Runtime} process using UTF-8 encoding.
	 * 
	 * @throws IOException
	 */
	public ReadlineRuntime(String[] args, String[] envp, File dir,
	                       Logger logger) throws IOException {
		this(args, envp, dir, "UTF-8", logger);
	}

	/**
	 * Fork out a new {@link Runtime} process using UTF-8 encoding and running
	 * in the CWD.
	 * 
	 * @throws IOException
	 */
	public ReadlineRuntime(String[] args, String[] envp, Logger logger)
	        throws IOException {
		this(args, envp, null, "UTF-8", logger);
	}

	/**
	 * Fork out a new {@link Runtime} process using UTF-8 encoding and running
	 * with the currently set environment variables.
	 * 
	 * @throws IOException
	 */
	public ReadlineRuntime(String[] args, File dir, Logger logger)
	        throws IOException {
		this(args, null, dir, "UTF-8", logger);
	}

	/**
	 * Fork out a new {@link Runtime} process using UTF-8 encoding and running
	 * in the CWD with the currently set environment variables.
	 * 
	 * @throws IOException
	 */
	public ReadlineRuntime(String[] args, Logger logger) throws IOException {
		this(args, null, null, "UTF-8", logger);
	}

	/**
	 * Fork out a new {@link Runtime} process that has no parameters.
	 * 
	 * @param command the single command to run
	 * @param envp environment parameters for the Runtime process (as
	 *        <i>name=value</i> strings)
	 * @param dir to run the process in
	 * @param logger to handle the error stream
	 * @param encoding for the readline interface
	 * @throws IOException on failure
	 */
	public ReadlineRuntime(String command, String[] envp, File dir,
	                       String encoding, Logger logger) throws IOException {
		this(new String[] { command }, envp, dir, encoding, logger);
	}

	/**
	 * Fork out a new {@link Runtime} process using UTF-8 encoding.
	 * 
	 * @throws IOException
	 */
	public ReadlineRuntime(String command, String[] envp, File dir,
	                       Logger logger) throws IOException {
		this(command, envp, dir, "UTF-8", logger);
	}

	/**
	 * Fork out a new {@link Runtime} process using UTF-8 encoding and running
	 * in the CWD.
	 * 
	 * @throws IOException
	 */
	public ReadlineRuntime(String command, String[] envp, Logger logger)
	        throws IOException {
		this(command, envp, null, "UTF-8", logger);
	}

	/**
	 * Fork out a new {@link Runtime} process using UTF-8 encoding and running
	 * with the currently set environment variables.
	 * 
	 * @throws IOException
	 */
	public ReadlineRuntime(String command, File dir, Logger logger)
	        throws IOException {
		this(command, null, dir, "UTF-8", logger);
	}

	/**
	 * Fork out a new {@link Runtime} process using UTF-8 encoding and running
	 * in the CWD with the currently set environment variables.
	 * 
	 * @throws IOException
	 */
	public ReadlineRuntime(String command, Logger logger) throws IOException {
		this(command, null, null, "UTF-8", logger);
	}
	
	/** Log a message. */
	public void log(Level lvl, String msg) {
		logger.log(lvl, msg);
	}

	/** Stop the runtime process and logger thread. 
	 * @return */
	public synchronized void stop() throws IOException {
			proc.destroy();
			in.close();
			out.close();
	
			if (logger.isAlive()) {
				logger.interrupt();
				logger.halt();
			}
	}

	/**
	 * Process an input line, reading the response (implemented by
	 * {@link #readResponse()}).
	 * 
	 * @param line the input line
	 * @return the parsed response
	 * @throws IOException on IO failures
	 */
	public synchronized T process(String line) throws IOException {
		in.write(line);
		in.newLine();
		in.flush();
		return parseResponse();
	}

	/**
	 * Return a single, trimmed line from the process' output stream.
	 * 
	 * @throws IOException on IO failures
	 */
	protected String readLine() throws IOException {
		return out.readLine().trim();
	}

	/** Implement the parsing of output lines here, using {@link readLine()}. */
	protected abstract T parseResponse() throws IOException;

}
