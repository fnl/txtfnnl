package txtfnnl.subprocess;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

import org.apache.uima.util.Level;
import org.apache.uima.util.Logger;

/**
 * Implement a process wrapper based on a readline input and output stream with a UIMA
 * {@link org.apache.uima.util.Logger Logger} that prints the error stream. The output stream
 * should parsed/converted to a generic type, which needs to be implemented by any children,
 * including the number of output lines to read before generating a result.
 * 
 * @author Florian Leitner
 */
public abstract class ReadlineRuntime<T> {
    /** The forked process. */
    final Process proc;
    /** The stream to send data to the forked process. */
    final BufferedWriter in;
    /** The stream to fetch data from the forked process. */
    final BufferedReader out;
    /** The error stream generated by the forked process. */
    final ReadlineLogger logger;

    /**
     * Fork out a new {@link Runtime} process.
     * 
     * @param args for the Runtime process
     * @param envp environment parameters (as <code> <i>name</i>=<i>value</i>
     *        </code> strings) for the Runtime process
     * @param dir to run the process in (if null, use the working directory of the current process)
     * @param encoding for the readline interface
     * @param logger to handle the error stream
     * @throws IOException on failure
     */
    public ReadlineRuntime(String[] args, String[] envp, File dir, String encoding, Logger logger)
            throws IOException {
        if (args == null || args.length == 0)
            throw new RuntimeException("trying to start a runtime without arguments");
        logger.log(Level.FINE, "starting a {{1}} encoded runtime process for ''{{0}}''",
            new Object[] { args[0], encoding });
        proc = Runtime.getRuntime().exec(args, envp, dir);
        out = new BufferedReader(new InputStreamReader(proc.getInputStream(), encoding));
        in = new BufferedWriter(new OutputStreamWriter(proc.getOutputStream(), encoding));
        this.logger = new ReadlineLogger(proc.getErrorStream(), logger);
        this.logger.start();
    }

    /**
     * Fork out a new {@link Runtime} process using UTF-8 encoding.
     * 
     * @see ReadlineRuntime#ReadlineRuntime(String[], String[], File, String, Logger)
     * @throws IOException
     */
    public ReadlineRuntime(String[] args, String[] envp, File dir, Logger logger)
            throws IOException {
        this(args, envp, dir, "UTF-8", logger);
    }

    /**
     * Fork out a new {@link Runtime} process using UTF-8 encoding and running in the CWD (
     * <code>System.getProperty("user.dir")</code>).
     * 
     * @see ReadlineRuntime#ReadlineRuntime(String[], String[], File, String, Logger)
     * @throws IOException
     */
    public ReadlineRuntime(String[] args, String[] envp, Logger logger) throws IOException {
        this(args, envp, null, "UTF-8", logger);
    }

    /**
     * Fork out a new {@link Runtime} process using UTF-8 encoding and running with the currently
     * set environment variables.
     * 
     * @see ReadlineRuntime#ReadlineRuntime(String[], String[], File, String, Logger)
     * @throws IOException
     */
    public ReadlineRuntime(String[] args, File dir, Logger logger) throws IOException {
        this(args, null, dir, "UTF-8", logger);
    }

    /**
     * Fork out a new {@link Runtime} process using UTF-8 encoding and running in the CWD with the
     * currently set environment variables.
     * 
     * @see ReadlineRuntime#ReadlineRuntime(String[], String[], File, String, Logger)
     * @throws IOException
     */
    public ReadlineRuntime(String[] args, Logger logger) throws IOException {
        this(args, null, null, "UTF-8", logger);
    }

    /**
     * Fork out a new {@link Runtime} process that has no parameters.
     * 
     * @param command the single command argument needed to run the process
     * @param envp environment parameters for the Runtime process (as <i>name=value</i> strings)
     * @param dir to run the process in
     * @param logger to handle the error stream
     * @param encoding for the readline interface
     * @see ReadlineRuntime#ReadlineRuntime(String[], String[], File, String, Logger)
     * @throws IOException on failure
     */
    public ReadlineRuntime(String command, String[] envp, File dir, String encoding, Logger logger)
            throws IOException {
        this(new String[] { command }, envp, dir, encoding, logger);
    }

    /**
     * Fork out a new {@link Runtime} process using UTF-8 encoding.
     * 
     * @see ReadlineRuntime#ReadlineRuntime(String, String[], File, String, Logger)
     * @throws IOException
     */
    public ReadlineRuntime(String command, String[] envp, File dir, Logger logger)
            throws IOException {
        this(command, envp, dir, "UTF-8", logger);
    }

    /**
     * Fork out a new {@link Runtime} process using UTF-8 encoding and running in the CWD.
     * 
     * @see ReadlineRuntime#ReadlineRuntime(String, String[], File, String, Logger)
     * @throws IOException
     */
    public ReadlineRuntime(String command, String[] envp, Logger logger) throws IOException {
        this(command, envp, null, "UTF-8", logger);
    }

    /**
     * Fork out a new {@link Runtime} process using UTF-8 encoding and running with the currently
     * set environment variables.
     * 
     * @see ReadlineRuntime#ReadlineRuntime(String, String[], File, String, Logger)
     * @throws IOException
     */
    public ReadlineRuntime(String command, File dir, Logger logger) throws IOException {
        this(command, null, dir, "UTF-8", logger);
    }

    /**
     * Fork out a new {@link Runtime} process using UTF-8 encoding and running in the CWD with the
     * currently set environment variables. This is the simplest possible constructor of a Runtime.
     * 
     * @see ReadlineRuntime#ReadlineRuntime(String, String[], File, String, Logger)
     * @throws IOException
     */
    public ReadlineRuntime(String command, Logger logger) throws IOException {
        this(command, null, null, "UTF-8", logger);
    }

    /** Log a message through the logger. */
    public void log(Level lvl, String msg) {
        logger.log(lvl, msg);
    }

    /** Log a message through the logger using the default log-level. */
    public void log(String msg) {
        logger.log(msg);
    }

    /** Stop the runtime process and logger thread. */
    public void stop() throws IOException {
        in.close();
        out.close();
        proc.destroy();
        if (logger.isAlive()) {
            logger.interrupt();
            logger.halt();
        }
        logger.stream.close();
    }

    /**
     * Stream an input line to the forked process, then hand over responsibility to parse the
     * response (which needs to be implemented by {@link #readResponse()}).
     * 
     * @param line the input line
     * @return the parsed response
     * @throws IOException on IO failures
     */
    public T process(String line) throws IOException {
        in.write(line);
        in.newLine();
        in.flush();
        return parseResponse();
    }

    /**
     * Return a single, trimmed line from the process' output stream. This method should be called
     * by the response parsing implementation and might return <code>null</code> if the forked
     * process' output stream was closed.
     * 
     * @throws IOException on IO failures
     */
    protected String readLine() throws IOException {
        String line = out.readLine();
        if (line != null) {
            line = line.trim();
        }
        return line;
    }

    /** Implement the parsing of output lines, using {@link readLine()}. */
    protected abstract T parseResponse() throws IOException;
}
