/* Created on Jan 3, 2013 by Florian Leitner.
 * Copyright 2013. All rights reserved. */
package txtfnnl.uima.pattern;

import java.util.List;
import java.util.regex.PatternSyntaxException;

import txtfnnl.pattern.Matcher;
import txtfnnl.pattern.Pattern;
import txtfnnl.uima.tcas.TokenAnnotation;

/**
 * A regular syntax expression pattern compiler for matching sequences of {@link TokenAnnotation
 * TokenAnnotations}.
 * <p>
 * A regular syntax expression must follow the following CF grammar rules, with each terminal
 * (enclosed in quotation marks below) separated by one or more spaces:
 * 
 * <pre>
 * S -> Phrase S? | Capture S? | Token S?
 * Phrase -> "[" Chunk InPhrase "]" "?"?
 * Capture -> "(" S ")"
 * InPhrase -> CaptureInPhrase InPhrase? | Token InPhrase?
 * CaptureInPhrase -> "(" InPhrase ")"
 * Chunk -> "NP" | "VP" | "PP" | "ADVP" ... # i.e., the tags generated by the chunker
 * Token -> "." Quantifier? | RegEx Quantifier?
 * Quantifier -> "*" | "?" | "+"
 * RegEx -> # see below #
 * </pre>
 * 
 * Note the extra <code>InPhrase</code> and <code>CaptureInPhrase</code> rules to ensure that
 * phrases are never nested. The special <code>Quantifier</code> terminals <code>*</code>,
 * <code>?</code> and <code>+</code> indicate any sequence of zero or more (*), zero or one (?), or
 * one or more (+) tokens should be consumed (non-greedily!), but limited by the current chunk tag
 * if used inside a chunk <code>Phrase</code>. For <code>Phrase</code> chunks, the <code>?</code>
 * quantifier (only!) may be used to indicate the entire chunk is optional. Note that, unlike the
 * Java RegEx language, the quantifiers may not be applied to (capture) groups. As with any RegEx
 * language, the <code>.</code> (dot) is used as a wild-card symbol to represent any possible
 * token; note that, if used within phrases (e.g., <code>[ NP . + ]</code>), the matching token(s)
 * still must have been annotated with the appropriate chunk tag.
 * <p>
 * <code>RegEx</code> is a terminal joining 1-3 Java Regular Expressions via underscores
 * <code>_</code>. (If the underscore or a whitespace character should form part of a RegEx, it has
 * to be escaped with a backslash <code>\</code>.)
 * <ol>
 * <li>The first (optional) field is a standard Java RegEx for the <b>raw token string</b>,</li>
 * <li>the second (optional) field is a Java RegEx for the token's <b>Part-of-Speech tag</b>,</li>
 * <li>and the third (required) field is a Java RegEx for the token's <b>stem or lemma</b>.</li>
 * </ol>
 * Any of these three RegEx fields can be replaced with an <code>*</code> to indicate that it may
 * contain any value (equal to using the RegEx <code>.*</code>, but with a more efficient matching
 * procedure). Therefore, the terminals <code>*</code>, <code>*_*</code> and <code>*_*_*</code>
 * would match any single token and are synonyms of the wild-card <code>.</code>. If any of the two
 * optional fields are omitted, the raw string or PoS tag of the token will always match - i.e.,
 * omitting an optional field is like a wild-card. An example token terminal matching the verb "is"
 * could be expressed as: <code>is_VBZ_be</code>. Note that for the case of matching any type of
 * token that has a single letter stem, this has to be written as <code>*_.</code>, because
 * <code>.</code> (dot) alone is used for the token wild-card.
 * <p>
 * Here are a few examples of regular syntax expressions:
 * <ul>
 * <li>
 * <li><code>( [ NP . + element|motif|sequence|site ] ) . * interact with [ NP ( . + ) ]</code>
 * This pattern would match a noun phrase "NP" with at least one word <code>. +</code> headed by
 * the stem "element", "motif", "sequence", or "site", followed by any number of tokens
 * <code>. *</code>, followed by the two stemmed tokens "interact" and "with", followed by any
 * possible noun phrase ("[ NP ( . + ) ]"); The tokens part of the two noun phrases will be
 * captured by this pattern ("( ... )"); note that it is irrelevant if the capture is enclosing the
 * phrase (first case) or vice versa (second case).</li>
 * <li><code></code></li>
 * <code>( [ NP . + NNP?S?_protein ] ) . * ( VB.?_bind|interact IN|TO_* ? [ NP . + gene ] )</code>
 * This pattern would match a two-or-more token noun phrase headed by the singular or plural,
 * possibly proper noun ("NNP?S?") with stem "protein", followed by any number of tokens, followed
 * by a any type of verb ("VB.?") with stem "bind" or "interact" and any optional preposition
 * conjunction ("IN|TO_* ?"), ending in a noun phrase with the stemmed head "gene". Furthermore,
 * the relevant tokens forming this "genetic interaction" would be captured in two capture
 * groups.</li>
 * </ul>
 * 
 * @author Florian Leitner
 */
public class SyntaxPattern extends Pattern<TokenAnnotation> {

  private SyntaxPattern() {
    throw new RuntimeException("n/a");
  }

  /**
   * Compile a syntax pattern from a regular expression.
   * 
   * @param regex pattern to be compiled
   * @throws PatternSyntaxException if the expression is illegal
   * @return a compiled pattern
   */
  public static Pattern<TokenAnnotation> compile(String regex) {
    RegExLexer scanner = new RegExLexer(regex);
    RegExParser parser = new RegExParser(scanner);
    Pattern<TokenAnnotation> pattern = parser.parse();
    if (scanner.hasNext()) { throw new PatternSyntaxException("unconsumed pattern content",
        scanner.toString(), scanner.offset()); }
    return pattern.minimize();
  }
  
  /**
   * Attempts to {@link Matcher#find() find} a pattern in a {@link TokenAnnotation} sequence.
   * 
   * @param expression pattern to be compiled
   * @param input token sequence to be matched
   * @throws PatternSyntaxException if the expression is illegal
   * @return <code>true</code> if the pattern matched the input
   */
  public static boolean matches(String expression, List<TokenAnnotation> input) {
    return compile(expression).matcher(input).find();
  }
}
